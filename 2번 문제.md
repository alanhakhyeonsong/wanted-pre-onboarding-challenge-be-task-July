# TCP와 UDP의 차이

OSI 7계층 중 4계층에서 동작하는 프로토콜의 목적은 **목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내는 것이다.**

## 4계층 프로토콜(TCP, UDP)과 서비스 포트

데이터를 보내고 받는 인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러가지 정보가 들어간다. 다양한 정보 중 가장 중요한 두 가지 정보는 다음과 같다.

- 각 계층에서 정의하는 정보  
  → 수신 측의 동일 계층에서 사용하기 위한 정보이다. 송신 측에서 추가한 2계층 헤더의 MAC 주소 정보는 수신 측의 2계층에서 확인하고 사용된다. 마찬가지로 송신 측에서 추가한 3계층 IP 주소는 수신 측 3계층에서 사용한다. 4계층의 정보는 시퀀스 번호, ACK 번호가 있다.
- 상위 프로토콜 지시자 정보  
  → 디캡슐레이션 과정에서 상위 계층으 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용된다.  
  2계층: 이더 타입  
  3계층: 프로토콜 번호  
  4계층: 포트 번호

TCP/IP 프로토콜 스택에서 4계층은 TCP와 UDP가 담당하는데, 4계층의 목적은 **목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것**이다.  
패킷을 분할하고 조립하기 위해 TCP 프로토콜에서는 **시퀀스 번호와 ACK 번호를 사용한다.**

![](https://images.velog.io/images/songs4805/post/8a6c77b5-14d5-4cd6-8eca-b9fb5148fd75/D9C3D0FA-C28A-4CFD-836D-4B34A2AD0880_1_102_a.jpeg)

> 📌 Well Known Port
>
> HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25와 같이 잘 알려진 포트를 Well Known 포트 라고 한다. 이러한 포트는 인터넷 주소 할당기구인 IANA(Internet Assigned Numbers Authority)에 등록되고 1023번 이하의 포트번호를 사용한다.

## TCP

TCP는 4계층의 특징을 대부분 포함하고 있다.

- 신뢰할 수 있다.  
  → 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능이 있다.
- 패킷에 번호(Sequence Number)를 부여해서 전송 상태를 확인한다.
- 잘 전송되었는지에 대한 응답(Acknowledge Number) 한다.
- 한 번에 얼마나 보내야 수신자가 잘 처리할 수 있는지 전송 크기(Window Size)까지 고려해 통신한다.
- 네트워크 상태를 크게 고려하지 않고 특별한 개발 없이도 쉽고 안전하게 네트워크를 사용할 수 있다.

### 패킷 순서, 응답 번호

![](https://images.velog.io/images/songs4805/post/1bff0e8a-bd88-42bb-a904-2c7bafc2b5d4/image.png)

- 분할된 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다.
- **시퀀스 번호**: 패킷에 순서를 부여하는 것
- **ACK 번호**: 응답 번호를 부여하는 것
- 두 번호(시퀀스, ACK)를 이용해 패킷의 순서가 바뀌거나 중간에 패킷이 손실된 것을 파악할 수 있다.
- 보내는 쪽에서 패킷에 번호를 부여하면 받는 쪽은 이 번호의 순서가 맞는지 확인한다. (이 숫자를 ACK 번호라 함)
- 송신 측에서 ACK 번호를 수신받으면 확인 후 다음 패킷에 번호를 부여해 송신한다.

![](https://images.velog.io/images/songs4805/post/0abca77c-7927-4551-aee4-0bda8ceace45/image.png)

1. 출발지에서 시퀀스 번호를 0으로 보낸다.(SEQ = 0)
2. 수신 측에서는 0번 패킷을 잘 받았다는 표시로 응답 번호(ACK)에 1을 적어 응답한다. 이때 수신 측에서는 자신이 처음 보내는 패킷이므로 자신의 패킷에 시퀀스 번호 0을 부여한다.
3. 이 패킷을 받은 송신 측은 시퀀스 번호를 1로(수신 측이 ACK 번호로 1번 패킷을 달라고 요청했으므로), ACK 번호는 상대방의 0번 시퀀스를 잘 받았다는 의미로 시퀀스 번호를 1로 부여해 다시 전송한다.

### 윈도 사이즈와 슬라이딩 윈도

- 윈도 사이즈: 한 번에 받을 수 있는 데이터의 크기
- 슬라이딩 윈도: 네트워크 상황에 따라 윈도 사이즈를 조절하는 것

TCP는 상대방이 얼마나 잘 받았는지 확인하기 위해 ACK 번호를 확인하고 다음 패킷을 전송한다. 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘리지만, 송/수신자간 거리가 멀수록 왕복 지연시간(RTT)이 늘어나므로 응답을 기다리는 시간이 더 길어진다.

그래서 데이터를 보낼 때 패킷을 하나만 보내는 것이 아니라 많은 패킷을 한꺼번에 보내고 응답을 하나만 받는다. 최대한 많은 패킷을 한꺼번에 보내는 것이 효율적이지만, 네트워크 상태가 안좋으면 패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 한다. 한 번에 데이터를 받을 수 있는 데이터 크기를 **윈도 사이즈**라 하고 네트워크 상황에 따라 이를 조절하는 것을 **슬라이딩 윈도**라 한다.

## 3방향 핸드셰이크

TCP는 유실없는 안전한 통신을 위해 통신 시작 전, 사전 연결작업을 진행한다. 목적지가 데이터를 받을 준비가 안 된 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려진다.

TCP 프로토콜은 이런 상황을 만들지 않기 위해 3번의 패킷을 주고받으면서 통신을 서로 준비하므로 '3방향 핸드셰이크'라 부른다.

![](https://images.velog.io/images/songs4805/post/0f659b5b-75e3-4f97-bf03-201101bdd18f/image.png)

3방향 핸드셰이크 과정이 생기다보니 기존 통신과 새로운 통신을 구분해야한다. 이를 구분하기 위해 헤더에 플래그(Flag)라는 값을 넣어 통신한다.

![](https://images.velog.io/images/songs4805/post/e7bafbe1-3217-4034-abf1-cf11dbb3f8a2/image.png)

TCP 플래그는 총 6가지가 있고 통신의 성질을 나타낸다. 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로 사용된다.

- SYN: 연결 시작 용도로 사용. 연결이 시작될 때 이 플래그에 1로 표시해 보낸다.
- ACK: ACK 번호가 유효할 경우 1로 표시해 보낸다. 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표기된다.
- FIN: 연결 종료 시 1로 표시된다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용된다.
- RST: 연결 종료 시 1로 표시된다. 연결 강제 종료를 위해 일방적으로 끊을 때 사용된다.
- URG: 긴급 데이터인 경우, 1로 표시해 보낸다.
- PSH: 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용.

![](https://images.velog.io/images/songs4805/post/c5ff9766-9d40-40ff-87f2-c23a3582b595/image.png)

3방향 핸드셰이크 과정은 위와 같다.

1. 통신 최초 시도시 송신자는 플래그에 있는 SYN 필드를 1로 표기하고 시퀀스 번호를 적어 보낸다.
2. SYN 패킷을 받은 수신자는 SYN, ACK 비트를 플래그에 1로 표기해 응답한다. 수신자가 보내는 첫 패킷이므로 SYN은 1이고 기존 송신자의 응답이기도 하므로 ACK 비트도 함께 1로 표기한다. 이 때 ACK 번호는 송신자가 보낸 시퀀스 번호에 1을 추가한 값을 넣어 응답한다. (시퀀스 번호로 10을 받았으니 ACK 번호는 11을 보내면 됨)
3. 수신자의 응답(SYN, ACK)을 받은 송신자는 연결을 확립하기 위해 다시 응답을 보낸다. 이때는 기존 메시지의 응답이기에 ACK 필드만 1로 표기된다. 수신자가 시퀀스 번호를 20으로 보냈기 때문에 송신자의 ACK 번호는 20+1인 21이 된다.

## UDP

UDP는 TCP와는 다르게 4계층 프로토콜이 가져야 할 특징이 거의 없다.

**TCP 헤더에 있던 내용들(시퀀스 번호, ACK 번호, 플래그, 윈도 사이즈 등)이 모두 존재하지 않는다.**  
데이터 통신은 데이터 전송의 신뢰성이 핵심이다. 애플리케이션에서 걱정하지 않고 데이터를 만들고 사용하게 하는 것이 데이터 통신의 목적이지만, **UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용된다.**

- 음성 데이터나 실시간 스트리밍  
  : 실시간성이 보장되야하는 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우 UDP 프로토콜이 사용됨
- 단방향으로 다수의 단말과 통신하며 응답을 받기 어려운 환경  
  : 사내 방송, 증권 시세 데이터 전송 등

즉, 신뢰성보다는 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 시스템에서 UDP를 사용한다. UDP는 중간에 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리해버린다.

또한 다음과 같은 특징이 있다.

- UDP는 TCP와 다르게 3방향 핸드셰이크처럼 사전에 연결을 확립하는 과정이 없다. 대신 UDP의 첫 데이터는 리소스 확보를 위해 인터럽트(interrupt)를 거는 용도로 사용되고 유실된다.
- UDP 프로토콜을 사용하는 앱 대부분은 이런 상황을 인지하고 동작한다.
- 연결 확립은 TCP 프로토콜을 이용하고 앱끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

📌 TCP와 UDP 특징 비교

| TCP                            | UDP                                  |
| ------------------------------ | ------------------------------------ |
| 연결 지향(Connection Oriented) | 비연결형(Connectionless)             |
| 오류 제어 수행함               | 오류 제어 수행 안 함                 |
| 흐름 제어 수행함               | 흐름 제어 수행 안 함                 |
| 유니캐스트                     | 유니캐스트, 멀티캐스트, 브로드캐스트 |
| 전이중(Full Duplex)            | 반이중(Half Duplex)                  |
| 데이터 전송                    | 실시간 트래픽 전송                   |
